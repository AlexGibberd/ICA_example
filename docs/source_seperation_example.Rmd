---
title: "Source Separation (The Submariner)"
author: "Alex Gibberd"
date: "2024-11-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

## Context

We are in a submarine and can listen to the world outside through sonar attatched to the outside of the vessel. Let's consider that we have $p$ different sensors. Each sensor can record a sound wave.

In the case where $p=2$ we have two sound recordings. These will contain a mixture of different sounds from sources that are in the nearby area, e.g., a source may be a ship, or a submarine, or even whale.

## Independent Component Analysis (ICA)

In this example, we will use a tool known as independence component analysis, that tries to take correlated (dependent) signals, and un-mix these (by taking a combination of the sound recordings) such that the un-mixxed signals appear to be independent of each other.

In the situation with the submarine, we may hope that the sound emitted by the other submarine and the ship are independent. This is reasonable, as the ship and submarine have their own engines, and typically these would not have any communication between them, e.g., there is no way the engine in one source may make another source give off a certain sound.

With this assumption in place, we can attempt to recover the original signals.

## Real-Data Example

In this case, we will know the true signals generated by the source (as we have recording of the boat and submarine seperately). We can examine how well the ICA algorithm recovers those sources, and listen to what the resultant signals sound like.

Before running the example, we will need to install and load some R packages. Use `install.packages("XYZ")` or use _Tools>Install packages_ in R Studio.

```{r}
library(tuneR)
library(fastICA)
library(signal)
library(caret)
library(glmnet)
```

_Note: Sound files are actually quite large, without compression these files are 15Mb and 8Mb respectively._

[https://maths.lancs.ac.uk/~gibberd/MATH334/](22__19_07_13_adventure_maniobtra.wav (Ship sound))
[https://maths.lancs.ac.uk/~gibberd/MATH334/](79__23_07_13_H3_zodiac.wav (Submarine sound))

You can use the code below to read in the data and then we will downsample the files (to make them a smaller size and easier to process). We can then plot the data to visualise it, and play the sounds. Note, it is hard to actually visaulise the whole sound file as there are so many samples.

```{r}
# Data can be downloaded from here:
# http://atlanttic.uvigo.es/underwaternoise/samples.zip

f1 <- '22__19_07_13_adventure_maniobra.wav'
f2 <- '79__23_07_13_H3_zodiac.wav'

w1 <- readWave(f1, from = 1, to = 600000,
         units = "samples", header = FALSE, toWaveMC = NULL)
w2 <- readWave(f2, from = 1, to = 600000,
               units = "samples", header = FALSE, toWaveMC = NULL)
w1 <- downsample(w1, 10000)
w2 <- downsample(w2, 10000)

par(mfrow=c(1,2))
plot(w1,simplify=TRUE, main="Oil Tanker")
plot(w2,simplify=TRUE, main="Submarine")
```

```{r,eval=FALSE}
# You will have to set up your own player below if you want to play the files.
# For mac, you can try
setWavPlayer('open -a \"iTunes.app\"')
# For windows
setWavPlayer(shQuote("C:/Program Files/Windows Media Player/wmplayer.exe"))

# To play the files in your media player, you can run:
play(w1)
play(w2)
```

Now we have the downsampled files, we can define a function that will mix these together. In this example, this function is actually a rotation matrix (if you are interested). After mutiplying the signal by this matrix we obtain a new sound, that is a mix of the original two. In this example, this mixing is an analogy for how the sounds would mix together as they pass through the water.

_Note: In real life, the mixing process is much more complex, and this is one reason this problem is much more challenging for a real submariner!_


```{r}
# Rotation (Matrix) Function
rotate <- function(theta){
  # Convert from degrees to radians
  theta = (theta/360)*2*pi
  R <- matrix(1,2,2)
  R[1,1] = cos(theta)
  R[1,2] = -sin(theta)
  R[2,1] = sin(theta)
  R[2,2] = cos(theta)
  return(R)
}

# The sources are recorded on two channels each
# For simplicity, we take the left hand channel on both sound files

X <- cbind(w1@left,w2@left)

# Rotate and Mix Signals
X2 <- X %*% rotate(45)

# Convert back to wav file
X2.wav = Wave(round(X2[,1]),samp.rate = 10000, bit=24)
```

We can now plot the signals. The plots on the left are what the submariner would observe on their sensors, the plot on the right is the sound emitted by the source
```{r}
# Visualise the rotated data and the original
par(mfrow=c(2,2))
time = (1:1000)/10000
plot(time,X2[1:1000,1],type = "l", xlab = "Time (s)", ylab = "Observed Sound",
     main = "Mixed signals")
plot(time, X[1:1000,1],type = "l", xlab = "Time (s)", ylab = "Tanker Sound",
     main = "Original signals")
plot(time, X2[1:1000,2],type = "l", xlab = "Time (s)", ylab = "Observed Sound")
plot(time, X[1:1000,2],type = "l", xlab = "Time (s)", ylab = "Submarine Sound")

```

```{r, eval=FALSE}
play(X2.wav)
```

We will use an algorithm called `fastICA` to do the de-mixing. This tries to rotate the observed signals until they 'look' like they are independent signals. How one measures independence (or lack of it) is quite a complex topic (you need to learn some information theory for this). It is worth to note there are many variants of ICA which use different measures to the example run here.


```{r}
# Independent Component Analysis
# Note: we set a seed here to enable reproducibility.
set.seed(1)
# Statistical method for unmixing signals based on the assumption that sources are independent

ica <- fastICA(X2, 2, alg.typ = "parallel", fun = "logcosh", alpha = 1,
               method = "R", row.norm = FALSE, maxit = 200,
               tol = 0.00001, verbose = FALSE)

X.norm <- X/sd(X)

# Let's plot the original signals (black) and compare to the estimated source signals (in red)

par(mfrow=c(1,2))
time =(1:500)/10000 # we only plot the first 0.05 seconds...
plot(time, X.norm[1:500,2],type="l",col="black", xlab = "Time (s)", ylab = "Target 1", main = "Target 1 Estimate/Truth")
lines(time,ica$S[1:500,1],col="red")
plot(time,X.norm[1:500,1],type="l",col="black", xlab = "Time (s)", ylab = "Target 1", main = "Target 2 Estimate/Truth")
lines(time, ica$S[1:500,2],col="red")

```

_What do we notice?_

The signals appear to be recovered, but are flipped upside down. This is because there is an _identifiability_ issue in ICA, we can try to find the different sources, but the order of estimated source 1 and source 2 may not match the original order. Also, the signs of the estimated sources may be flipped, i.e. $+1$ becomes $-1$. This is not much of a problem, as many important properties of the signals (e.g. characteristic sounds) do not depend on the direction of the signal. If you actually listen to these sounds they should sound simillar to your ear even though they are flipped.


We can also look at the error as measured by the root-mean-square error (RMSE):
```{r}
err1 = sqrt(sum((X.norm[1:1000,2]-(-1)*ica$S[1:1000,1])^2)/1000)
err2 = sqrt(sum((X.norm[1:1000,1]-(-1)*ica$S[1:1000,2])^2)/1000)
err1
err2
```
Comparing these values to the scale of the signal, we see they are relatively small. Indeed, once we flip the signs the right way round, we can see that the factICA algorithm recovers the original sources pretty well.

```{r}
par(mfrow=c(1,2))
plot(time, X.norm[1:500,2],type="l",col="black", xlab = "Time (s)", ylab = "Target 1", main = "Target 1 Estimate/Truth")
lines(time, -1*ica$S[1:500,1],col="red")
plot(time, X.norm[1:500,1],type="l",col="black", xlab = "Time (s)", ylab = "Target 1", main = "Target 2 Estimate/Truth")
lines(time, -1*ica$S[1:500,2],col="red")
```

## Applications in Economics

The example above looked at a specific method for un-mixing signals. However, analogous problems often occur in economics. For example, we have many economic variables recorded over time, and we desire to see if there are any latent economic states that may be driving these observations. Sometimes finding the underlying economic states (analogous to the original sources in above example) can be useful for investigating things like trends and business cycle behaviour.

## Important Skills for a World of Data

It is important that as students you can learn about techniques such as ICA, and other quantitative methods for processing large volumes of information. It is important not just to run the code, and use the package, but also understand what goes into the algorithms and the assumptions methods make. This is one of the great benefit of studying the Mathematics and Economics programme. It give you foundational skills to understand these methods, as well as a chance to practice using such tools to solve real problems, that are of interest to large organisations, governments and your future employers!

_I hope you enjoyed this tutorial, and look forward to seeing some of you in Lancaster for our BSc Mathematics and Economics programme. If you want more information on the programme, please do reach out to your teachers. You can also email me at a.gibberd@lancaster.ac.uk_




